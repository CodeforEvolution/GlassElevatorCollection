Multi-user

something similar to what Win2k does, where you try to do something and it says "you don't have permission to do that. If you are an admin, click here to enter the admin password for permission."

multiple users -  One or many at a time? Security for many at a time?

New Kit

vector math library to use mmx/sse/sse2/3/4/5

What about having a synthesized speech kit. Applications would send text (possibly with special marks) to the kit. Particular languageges could be available as plug-ins.

Voice recognition

Should we have help system? Pocket PC has very handy one, it's HTML-based. There's a folder somewhere, where are all your *.htm help files (for example, StyledEdit.htm). When you currently have StyledEdit opened and you open help, it goes directly to StyledEdit.htm file. When there's just empty desktop and you open help, it goes to index (automatically updated links to files in help folder). So,
whenever you install a program, the install script or package manager copies just one *.htm file to help folder. It's so easy to use, that OBOS should have it too. And there could be a simple search capablity within *.htm help files

synchronization kit  - some sort of way to notify and automatically update subscribers when data changes 

im kit

XML - possibly methods for BMessage to transform to and from XML, possibly a whole different kit

Encryption - a plug in architecture for encryption/decryption. Probably public/private key. With a key manager of some sort, so that it is easy for users. Also with a tie-in to the Mail Kit of some sort so that mail programs can quickly and easily encrypt and decrypt messages. Also a cache of public keys with methods to refresh them (via Networking Kit)

DataBase Kit - access for SQL databases will be a large sticking point to getting on the corporate desktop. The sooner the better.

Fax support (kit?)

Reference kit (dictionaries, thesaurus)

Media Kit

a BSound class that adds effects? Mute, slide, reverb, echo, etc. All, again, as plug ins.

Print Kit

Vastly improved printing is needed. Color management is huge, now, with digital photography. Additionally, more functionality is needed. Watermarks, more margin control, etc. All of those "extras" that you have on Windows and use once a year.

Device Kit

Why does serial port deserve a class but not BParallel? Or BAudioCD? Or BVideoCD? Or Scanners, Cameras, PDAs, etc? Every "thing" that you plug into your Haiku machine should have a class to access it. 

Game Kit

Sprites, Backgrounds, collision handling, parallax, 3d, scrolling, tiling, AI, controllers (joysticks, etc) and more. 

Translation Kit

How about 3D objects? Or vectors (structured drawing)? HTML read/write? 

Mail Kit

public/private key encryption for email

UI

ditch menu bars for context menus only

we should go vector. And we should adopt SVG as our standard.

this would be fantastic it would allow easy language localization of any part of OBOS (OS included) to a specific language and it would allow for users to have several languages available in is system in just one installation.

All higher layers of system should use some kind of localisation. This covers:
* Language translation files for applications
* Time and Date writing order/conventions
* Currencies
* Number spacing
* Keyboards
* Fonts ( why BeOS default fonts don't have more Latin european glyphs? )
* API/GUI should be able to fit different font sizes and string lengths (Example: Chinese has very big chars)
* yes systemwide Unicode/UTF-8 is a must

Localization - this is probably the single most requested feature. And one of the biggest. Because this ties into so many other things. At minimum, we need to add currency, calendar, number widgets, phone number, address that tie in to the locale. Plus automatic translation support (i.e. translate phrases into current locale's language), resizeable, font independent widgets, right to left and top to bottom text, etc. There is a *huge* amount of work in doing this right. Layout management, too, so that resized widgets can flow properly.

Dictionary of translated words, so that untranslated apps can be automatically (if imperfectly) translated.

How about being able to have a several applications using the same  window, each one having its own tab? I believe there are UNIX window  managers that do this though I've not tried them so I'm not sure how good it is in practice. I imagine there would be pros and cons.

just wanted to say that some GUI description language (XUL?) is a really nice thing to have in R2. :)

include a standard widget for toolbars,	Some thinks I like about some toolbars:
* drop-down buttons.
* animated icons.
* separators
* options per toolbar - small icons, text under icon.
* !!! configuration tool - add/remove button on the fly !!!

ability to collapse the menubar into a clickable icon for more screen space (maybe even into the tab?) 

Additions to BBitmap - this class is really in need of a lot more "stuff". Think LeadTools for Windows - the ability to choose some area of the bitmap and apply transforms (plug ins). This has been done a dozen times for a dozen different art programs. Let's do it once more, possibly leveraging someone else's work and make it part of the OS.

BHTMLView - include JavaScript? External players? Use some existing framework?

How about an Outlook bar? Or a grid widget? Many new controls possible, look at other OSs. Graphs and charts

How about a BImageFilePanel? One that queries the device system for image yielding devices and has neat features like thumbnails, etc? Or a BSoundFilePanel that lets you play snippets before loading the whole file? Still-Image Acquisition & Moving-Image Acquisition

RAD / easy graphical GUI-creation toolkit

Color Management

Multiple monitor support

Kernel

ability to move processes from one machine to another (load balancing)

Anyway, a good thing to add is device feedback. This way drivers would be able to implement force-feedback stuf for mouses, for example.

a way for driver to carry themself a standardly formated database of their support.  It could only be metadata. It would allow querying to discover if certain functionality exists in the driver and/or the hardware

Power Management and other "special" laptop support

Bluetooth

FireWire

CardBus/PC Card

PCI Express

64-bit processors

Debugging via the kernel

Zeroconf / Rendezvous

RAID (hardware and software)

HW-accelerated OpenGL

Tracker

Not only does it offer a more efficient space, it enhances the usefulness of the OS by offering a place to stash information vital to the user.  Some  examples of replicants that could be of use would be a pulse like CPU  histogram, a virtual workspace manager, a clock and calendar, controller for  audio players, applications/script/folder shortcuts and a drive space  monitor, to name a few.  I'm sure others can come up with more.  It would be  left up to the user to decide what they want to display as a deskbar  replicant, in what order they want them displayed and how they want it  displayed. 

what if "My Computer" opened into a mime type directory. You could either look at a type's subtypes OR look at the files with that mime type.

In the Tracker with an icon(or icons) highlighted, you decide to copy them to another directory.  You simply right click, move the cursor over Copy To and you then procede to find the directory you wish to copy them to. Now you find a few more files(we will use mp3s as an example) that you wish to copy to the same directory.  You simply right click, move the cursor down to Copy To, but this time when the next menu forms their is an option at the top that says Most Recent or Recent.  Moving to the right on this item shows you the last 5 or 10 directories that you have copied to.  This functionality would be available from the Create Link, Copy To, and Move To popup menus. 

integrate xcv ( http://www.bebits.com/app/1734)

This could be implemented like this: when the appropriate file is  highlighted, make Tracker extend its viewable area, like a drawer, and  this drawer should work like R4's Container; attach a new replicant that 
can handle this file type. BeMail could be made a replicant, NetPositive  already is (could be the handler for graphic files), SoundPlay also...

Folder backgrounds are stored as an attribute of the folder.  Why can't we preview images by clicking once on them and have Tracker send them into the open folder's background attribute?  For that matter, any type of data/media could be handled the same way.  Video, audio - all that stuff.  We can even have tracker do cool things like make a split pane to preview emails and text documents (any kind of document that we have a "tool" reader for - gobe, word,abiword, etc.).  

What about allowing "rules" for file management on the desktop, i.e when files are dropped there.

BFS
I think it would be useful to have attributes with both a name and an index: you could get the 6th attribute named "foo", for instance. This is useful because it lets you associate more than one value with a 
single attribute in a system-defined way. If we had an installer that tracked what libs an app depended on, it could place those in attributes and query for them, without worrying about seperating the  lib names with some kind of token. MP3s could have multiple authors. We could also give translators an attribute for what they translate, which would make this obvious to the user, *and* obviate the roster: the system would know where it was going. Currently, we have only one value for attributes which is very annoying with a Contact's email addresses: we use tricks like "Person:Email"="first@mail.com, second@othermail.com". This has to be changed.
Think of BMessage: "Person.Email" gets an array of values:
"Person.Email"[0] = first@mail.com
"Person.Email"[1] = second@mail.com
How this is handled with indices: the "Person.Email" index may simply contain multiple entries pointing to the same file.

Full text indexing

Components

The micro solution consists of reverting to the computing roots of the D+F concept (data and functions, no programs).  That is, the killer app for GE is that there is NO app.  Your system consists of functions which the user invokes in which ever order they choose, and vendors ONLY provide functions. They no longer provide programs.  The entire User Interface has to be changed to allow for an entire different concept of work flow.  Let me repeat that one more time - a new work flow requires a change in the user interface (think fundamental change like the change from CLI to WIMP). 

I connect the Cron component to the MediaPlayer object and boom - alarm clock. This is what OO was supposed to bring to coders. We are talking about bringing it to end users. Of couse, just like, say, themes, there will be builders and there will be users. But what we are really talking about is making coding message based and more component-ized.
The idea of wrapping complex structures in one binary file & using special dev/apps tools to poke inside seems to be giving way to keeping 1 simple type in each file, & letting a folder keep it all together.
Advantage is any suitable app can edit specific components. Apple used to use resource forks with ResEdit, now they want all to use the hidden folder approach. Much much easier on tool developers since you reusewhat is already out there.

Lets make it cooler, you get your components, link them up Cortex style  and save them as new processes Imagine browsing through your Video directory and previewing the video using the folder's background as a screen.  The icons maybe will become slightly transparent so that you can see the video a little clearer, but not much because it is - after all - just a preview to see if it's the right document.

Input Kit

fix the InputServerMethod issues. 

I also have been thinking of moving Joysticks to the input_server.

allow users to determine the order in which input is passed to the InputServerFilters.

allow for system wide key bindings

MIME/Roster

File types are more human-readable: Document, Image, Video, etc. In our local database we store the MIME translations for those types. Multiple-inheritance is supported, too (OGG would inherit from Audio and Video, for example). Instead of specifying attributes for each format individually (MP3 has its own attribute set) the attributes are inherited from the supertype  (Audio). Internally, the file types are stored as MIME. This allows for better OS-interoperability, backwards-compatibility, and more flexibility (we can change the inheritance structure of the whole type database and it will continue to work). But there is a problem with this model: global queries (Audio/*) would have to look for multiple MIME-types (application/ogg, audio/*, etc.). Nevertheless, it should be a step forward, usability-wise.

BClipBoard - ability to have multiple items on the clipboard

Support Kit

Lots of new classes for here, too. There are numbers of useful little helper classes that we could all use... How about a pool allocator, as an example.

Included Apps

CD/DVD Writer

scanning/digital camera import

TV Tuner

Data Exchange Kit would be a superset of the Device kit in such a way as to allow for the exchange of various kinds of data in a way similar to the Media Kit's codecs and the Translation Kit's translators. The kit could act as a go-between between the host computer and a device, such as a DV camera, a scanner, a PDA or whatever.Cortex for Data.

Other

Package Management - single file bundles like OSX or something else?

User preferences keyfob (flash storage)  - on boot/disk insertion, check to see if there is a removable volume mounted that has a home directory on it. If so, boot using this as home; allows visiting users to bring their preferences/apps/data with them. Basically a Haiku install minus the system on a flash drive/cd/whatever

RPC (SOAP, XML, Web services etc.) - not sure if this is network kit or ???


